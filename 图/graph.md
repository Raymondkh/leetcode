# 图

## 回顾数据结构
1. 集合：数据元素间除“同属于一个集合外，无其他关系
2. 线性结构：1:1，如线性表、栈、队列
3. 树形结构：1：n
4. 图形结构：n:m（每个结点都可以有多个前驱多个后继，即多对多）

## 图概念
1. 图 G(V, E)--Graph(Vertex, Rdge) --V：顶点（数据元素）的 有穷非空集合；E：边的有穷集合（图不为空时至少包含一个顶点）
2. 有向图：每条边都是无方向的
3. 无向图：每条边都是有方向的
4. 完全图：任意两个点都有一条边相同
  1. 无向完全图：n个顶点共有n(n-1)/2条边
  2. 有向完全图：n个顶点共有n(n-1)条边 (为无向图的两倍)
5. 弧：有向图的边也可称为弧
6. 稀疏图：有很少的边或弧的图(e < nlogn)
7. 稠密图：有较多边或弧的图
8. 网：边或弧 带权（权重） 的图（权重表明从一个顶点到另一个顶点的距离或耗费）
    1. 图：无权重
    2. 网：有权重
9. 邻接： 有边或弧相连的两个顶点之间的关系
    1. (Vi, Vj)则称为Vi,Vj互为邻接点, （）是无向图
    2. <Vi, Vj>则称为Vi邻接到Vj, Vj邻接与Vi, <>有向图,前者指向后者
10. 关联（依附）：边或弧与顶点之间的关系
11. 顶点的度：与该顶点相关联的边的数目
    1. 有向图中，顶点的度TD(v) = 顶点的入度ID(v) + 顶点的出度OD(v)
    2. 当有向图中仅有1个顶点的入度为0，其余顶点的入度为1---->树（有向树）
12. 路径：接续的边构成的顶点序列
13. 路径长度：路径上边或弧的数目/权值之和
14. 回路(环)：第一个顶点和最后一个顶点相同的路径
15. 简单路径：除路径起点和终点可以相同之外，其余顶点均不相同的路径
    1. 简单回路(简单环)：除路径起点和终点相同之外，其余顶点均不相同的路径
16. (连通图->无向图；强连通图->有向图)：在图中，如任意两个顶点都在存在可互相达到的路径（注意有向图是要能互相达到的,路线有方向）
17. 子图：顶点和边都是包含在整图中
18. 连通分量(强连通分量)：无向图G的极大连通子图成为G的连通分量
    1. 极大连通子图：该子图是G连通子图，将G的任何不在该子图中顶点加入，子图会不再连通，说明现在是能连通的子图（顶点式不一定是能连通的最大，而是当前情况可以连通的情况）
19. 极小连通子图： 连通子图+删除一条边将不再连通
    1. 生成树： 包含无向图G所有顶点的极小连通子图
    2. 生成森林
    
### 图的数据类型
1. 抽象数据类型定义：数据对象+数据关系
2. 图的操作：
    1. GreateGraph()图的创建：生成一个没有顶点的空图G
    2. GetVex(G,v)获取顶点v的值：
    3. DFGTraverse(G):深度优先遍历
    4. BFSTraverse(G):广度优先遍历

## 图的存储结构
#### 邻接矩阵(数组表示法)--图
1.  建立一个顶点表(记录个顶点信息)和一个邻接矩阵（表示各顶点之间的关系）
2. 顶点表(一维矩阵)
3. 邻接矩阵(二维矩阵)：n*n,有边则取1，无边则取0
4. 无向图
    1. 邻接矩阵：对角线为0，对象线对称矩阵  
    2. 每一行中1的个数=该顶点的度
    3. 完全图的邻接矩阵除对角线之外全是1
5. 有向图
    1. 邻接矩阵的1为该行的顶点发出的弧（尾--->头）
    2. 第i行的含义：以结点Vi为尾的弧（即出度边）--顶点的出度=第i行元素之和
    3. 第i列的含义：以结点Vi为头的弧（即入度边）--顶点的入度=第i列元素之和
    4. 顶点的度=第i行的元素之和+第i列元素之和
#### 邻接矩阵(数组表示法)--网：即有权图
1. 邻接矩阵的值为权重值(有边) 或 无穷（表示无边，需要一个特定值来表示）--（疑问：为什么要使用无穷值来表示无边呢？是权重也可以取到负值和0吗？在书中来看，权重、对角线0值、无边无穷值 三者之间相互区分）
```
# 图的抽象数据类型的操作
ADT Graph:
  Graph(self)    # 创建一个新图
  is_empty(self) # 判断是否为一个空图
  vertex_num(self) # 获得图中的顶点个数
  edge_num(self) # 获得图中边的条数
  vertices(self) # 获得图中顶点的集合
  edges(self) # 获得边的集合
  add_vertex(self, vertex) # 将顶点vertex加入这个图中,是新增加一个顶点则为增加一个新行且每一行都需要增加一个新的元素
  add_edge(self, v1, v2) # 将从v1到v2这条边的信息加入图中
  get_edge(self, v) # 获得v1到v2边有关信息，没有的时候返回特殊值
  out_edges(self, v) # 取得从v出发的所有边
  degree(self, v) # 检查v的度
"""
以上均应该按照应用的需求来实现操作
需要考虑是无向图或有向图，对于有向图需要考虑，顶点需要分为出度或入度，邻接边需区分出边还是入边
实际使用中一般只使用出度或出边
"""
"""
遍历重要的两点关键
- 图中可能有回路，到统一顶点可能有多条路径（树中没有这种情况）。因此在遍历中需要避免再次进入已经遍历过的部分
- 图中有可能不连通，或者这个图不是有根图，即使是有根图，算法也可能没有从图中根开始遍历。因此，要完成对一个图里所有顶点（或边）的遍历，遍历完图中可达的那个部分（在无向图里是一个连通分量，在有向图里是一个或几个强连通分量），并不一定是整个图的遍历的结束，还需要考虑从初始顶点不可达的部分
"""
"""
python实现
1. 两层list or 两层 tuple
2. dict 以顶点的下标序(i, j)作为关键码，1表示有边，None表示无边，检索效率为O(1)，适合表示稀疏矩阵
3. 使用python内置的bytearray字节向量类型或标准库中array类型
   bytearray是内置类型，与str类似，但为可变类型，bytearray对象的元素是二进制字节，可以用于表示边存在与否。存储效率较高
   array是标准库中定义的数值汇集类型，起对象的元素可以是整数或浮点数等基本类型的值，可用于表示带权图
4.无穷大的值：
  inf = float("inf")  # inf值大于任何float类型的值
"""
```
```
伪代码C语言：
# define MVNUM 100 // 最大顶点数
typedef char VerTexType; // 设顶点的数据类型为字符类型
typedef int ArcType;  // 假设边的权重类型为整形

typedef struct{
  VerTexType verx[MVNUM]; // 顶点表
  ArcType arcs[MVNUM][MVNUM]; // 邻接矩阵
  int vexnum, arcnum; // 图当前的点数和边数
}AMGraph; 


  
```

    
     

#### 邻接表(链表)--重要
#### 邻接多重表(链表)
#### 十字链表(链表)


    
    
    
    
    
    

